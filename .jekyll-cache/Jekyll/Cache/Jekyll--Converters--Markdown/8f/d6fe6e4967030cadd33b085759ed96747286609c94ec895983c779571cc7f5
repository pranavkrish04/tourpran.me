I"ñ<h3 id="introduction">Introduction:</h3>

<p>This is an initiative taken by team members of ARESx. In this series of <code class="language-plaintext highlighter-rouge">pwn-training</code> we will be looking into various types of attacks performed on binaries. This in the first part of the series. We will start of slow with a simple return to shellcode challenge. Most of the challenge binary‚Äôs code will also be provided.</p>

<h3 id="challenge">Challenge:</h3>

<p>Here we are given a binary and the source for the binary.</p>

<p><a href="/assets/images/pwntraining1/ret2shellcode">vuln binary</a> and 
<a href="/assets/images/pwntraining1/ret2shellcode.c">vuln c code</a></p>

<h3 id="solution">Solution:</h3>

<h4 id="mitigations">Mitigations:</h4>

<p>Before goinging into the exploitation its better to check what mitigations are enabled for a bianry. Mitigations are protections that were included to avoid certain attacks. for example.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>checksec <span class="nt">--file</span> ./ret2shellcode
</code></pre></div></div>

<p><img src="/assets/images/pwntraining1/pwntrain1.png" alt="" /></p>

<p>if you don‚Äôt have checksec installed then</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>checksec
</code></pre></div></div>

<p>RELRO:</p>
<ul>
  <li>Partial RELRO - in attackers point of view, does nothing but leaves the got writeable.</li>
  <li>Full RELRO    - makes the GOT read-only therefore mitigating the ‚Äúgot-overwrite‚Äù attack. (got-overwrite coming soon ;) )</li>
</ul>

<p>CANARY:</p>
<ul>
  <li>its a set of characters stored on the stack to make sure no buffer overflows takes place. (we can bypass this later)</li>
</ul>

<p>No eXecute:</p>
<ul>
  <li>NX Enabled - this makes sure that the code on the stack is not excecuted.(not that simple but lets go with this for now)</li>
  <li>NX Disabled - yea you guessed it. the code on the stack can be excecuted.</li>
</ul>

<p>PIE:</p>
<ul>
  <li>position independent excecutable: will randomise the address of the code and PLT.</li>
  <li>point to note : the libc address will always be different cause they are PIC (Position Independent Code). even they dont know where they are loded lmao.</li>
</ul>

<p>RWX:</p>
<ul>
  <li>Read, write and execute : It‚Äôll tell us if the binary has segments that we can write and excecute.</li>
</ul>

<h4 id="code-walkthrough">Code walkthrough:</h4>

<p>IF you are a curious assembly code lover make sure to head over to the gdb and dig deep. Here ill go through the c code since its a basic writeup.</p>

<p><img src="/assets/images/pwntraining1/pwntrain2.png" alt="" /></p>

<p>Just ignore the ignore_me() function its for standard buffering and stuff. There are 2 functions called win and main. looking at main we see there is a buf variable with size 0x60 and a puts call. there is also a printf that will leak the address of the buf variable [intresting].</p>

<p>There is another function called gets(). we all at this point know its a dangerous function. lets see why.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>man gets
</code></pre></div></div>
<p><img src="/assets/images/pwntraining1/pwntrain3.png" alt="" /></p>

<p>seems like gets will take input as long as there is a newline character which means we can get past the buf variable and mess things in the <code class="language-plaintext highlighter-rouge">stack</code>. So this stack is just a memory region where all the static allocations happen. lets open this in gdb and see what is happening.</p>

<p>I have a different version / flavour of gdb called pwndbg. <a href="https://github.com/pwndbg/pwndbg">link to download</a></p>

<pre><code class="language-gdb">disass main
</code></pre>
<p><img src="/assets/images/pwntraining1/pwntrain4.png" alt="" /></p>

<p>i know a lot of shit is happening but dont worry we only want to set a break point in the return at the end. These breakpoints are stops that‚Äôll happen at specific address that you define when you run the binary in gdb.</p>

<pre><code class="language-gdb">b* 0x0000000000401238
</code></pre>
<p>b for break and give the address of ret at the end of main. Now run the binary and see if you can crash it in someway. Go ahead and see if oyu can get some crash in the binary.</p>

<p>Great if you got a <code class="language-plaintext highlighter-rouge">segfault</code> else no worries. well do it together. run the binary in gdb with <code class="language-plaintext highlighter-rouge">r</code> and then give 0x60 ‚Äúa‚Äùs . this will fill up the buf variable. after those random ‚Äúa‚Äùs maybe create a offset pattern like <code class="language-plaintext highlighter-rouge">111111112222222233333333</code></p>

<p><img src="/assets/images/pwntraining1/pwntrain5.jpg" alt="" /></p>

<p>ooof dont worry. there is a lot of information about different registers in the image but we are particularly intrested in 1 register called rsp. The rsp is the stack pointer or the register that holds infomartion about the next location to excecute. But do you see something fishy there ? Exactly we can control the return address of main. This means that we can make the binary excecute what we want.</p>

<h4 id="aim">Aim:</h4>

<p>As an attacker our aim is to make this binary give a shell for us in the server. So we looked at a win() function earlier, this will land us a nice neat shell! Tho there wont be any win() function in real life applications, its your task to somehow find ways to get a shell in the server.</p>

<h4 id="return-to-win">Return to win:</h4>

<p>now since we control the return address of main why not lets change the return address to win function ?</p>
<ul>
  <li>Win function does execve(‚Äú/bin/sh‚Äù) -&gt; which means that it‚Äôll call a system function called <code class="language-plaintext highlighter-rouge">execve</code> and excecute the command <code class="language-plaintext highlighter-rouge">/bin/sh</code> which is a shell.</li>
</ul>

<p>ok lets start writing our script in python. First we will import pwntools library to make things easier. next we will connect to our binary and send/recieve messages.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s">"ret2shellcode"</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">b"a"</span><span class="o">*</span><span class="mh">0x60</span> <span class="o">+</span> <span class="s">b"a"</span><span class="o">*</span><span class="mi">8</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00000000004011a5</span><span class="p">))</span>
<span class="n">p</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>Here in the sendline command I am giving ‚Äúa‚Äù * 0x60 to fill the buf variable and extra ‚Äúa‚Äù * 8 to fill the rbp (base pointer) and then the address of win function. wait what is that p64() ? -&gt; p64() function will make your address into little endian format.</p>

<p>Run this script and lets see what we get. SHOOT you get something called EOF (End Of File) ?</p>

<p><img src="/assets/images/pwntraining1/pwntrain6.png" alt="" /></p>

<p>You can attach a gdb with your script and see where your script will crash / how it runs. But we are already given the c code and we know that there was some addictional checks done to the <code class="language-plaintext highlighter-rouge">execve</code>.</p>

<p><img src="/assets/images/pwntraining1/pwntrain7.png" alt="" /></p>
:ET